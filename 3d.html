<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>3D 粒子手势高阶交互系统</title>  
    <style>  
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }  
          
        /* HUD 界面风格 */  
        #hud {  
            position: absolute;  
            top: 20px;  
            left: 20px;  
            color: #00ffcc;  
            pointer-events: none;  
            z-index: 10;  
            text-shadow: 0 0 5px #00ffcc;  
        }  
        .panel-item { margin-bottom: 10px; background: rgba(0, 20, 20, 0.6); padding: 10px; border-left: 3px solid #00ffcc; }  
        h2 { margin: 0 0 5px 0; font-size: 18px; text-transform: uppercase; }  
        p { margin: 0; font-size: 14px; opacity: 0.8; }  
        .highlight { color: #fff; font-weight: bold; }  
  
        /* 状态指示灯 */  
        #mode-indicator {  
            position: absolute;  
            top: 20px;  
            right: 20px;  
            display: flex;  
            gap: 10px;  
        }  
        .mode-box {  
            padding: 8px 15px;  
            border: 1px solid #333;  
            color: #555;  
            background: rgba(0,0,0,0.8);  
            border-radius: 4px;  
            font-size: 12px;  
            transition: 0.3s;  
        }  
        .mode-box.active {  
            border-color: #00ffcc;  
            color: #00ffcc;  
            background: rgba(0, 255, 204, 0.1);  
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);  
        }  
  
        /* 视频反馈 */  
        #video-container {  
            position: absolute;  
            bottom: 20px;  
            left: 20px;  
            width: 160px;  
            height: 120px;  
            border: 1px solid #333;  
            opacity: 0.5;  
            z-index: 5;  
            transform: scaleX(-1);  
        }  
        video { width: 100%; height: 100%; object-fit: cover; }  
          
        #loading {  
            position: absolute;  
            top: 50%; left: 50%; transform: translate(-50%, -50%);  
            color: white; font-size: 20px;  
        }  
    </style>  
  
    <!-- 引入库 -->  
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>  
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>  
</head>  
<body>  
  
    <div id="loading">系统初始化中...</div>  
  
    <!-- 状态显示区域 -->  
    <div id="hud">  
        <div class="panel-item">  
            <h2>系统状态</h2>  
            <p>手势: <span id="gesture-name" class="highlight">未检测</span></p>  
            <p>FPS: <span id="fps-counter">0</span></p>  
        </div>  
        <div class="panel-item">  
            <h2>操作指南</h2>  
            <p>✋ [张开/握拳] -> 能量爆发/缩放</p>  
            <p>☝️ [食指] -> XY轴旋转 (视角)</p>  
            <p>✌️ [食指+中指] -> Z轴翻转 (滚转)</p>  
        </div>  
    </div>  
  
    <div id="mode-indicator">  
        <div id="mode-scale" class="mode-box">缩放/爆发模式</div>  
        <div id="mode-rotate-xy" class="mode-box">XY 视角旋转</div>  
        <div id="mode-rotate-z" class="mode-box">Z 平面翻转</div>  
    </div>  
  
    <div id="video-container">  
        <video id="input-video" playsinline></video>  
    </div>  
  
    <!-- Three.js -->  
    <script type="importmap">  
        {  
            "imports": {  
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"  
            }  
        }  
    </script>  
  
    <script type="module">  
        import * as THREE from 'three';  
  
        // --- 核心变量 ---  
        let scene, camera, renderer, particleSystem, pivotGroup;  
        const particleCount = 20000;  
          
        // 交互状态数据  
        const inputState = {  
            gesture: 'NONE', // NONE, OPEN, FIST, POINT, VICTORY  
            handDetected: false,  
            // 旋转相关  
            lastX: 0,  
            lastY: 0,  
            targetRotationX: 0,  
            targetRotationY: 0,  
            targetRotationZ: 0,  
            // 缩放相关  
            targetScale: 1,  
            burstFactor: 0 // 0 = 平静, 1 = 爆发  
        };  
  
        // 颜色配置  
        const colorBase = new THREE.Color('#00aaff'); // 蓝色 (平静)  
        const colorBurst = new THREE.Color('#ff0055'); // 红色 (爆发)  
          
        // 初始化  
        initThree();  
        initMediaPipe();  
        animate();  
  
        // --- Three.js 场景构建 ---  
        function initThree() {  
            scene = new THREE.Scene();  
            scene.fog = new THREE.FogExp2(0x050505, 0.02);  
  
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);  
            camera.position.z = 15;  
  
            renderer = new THREE.WebGLRenderer({ antialias: true });  
            renderer.setSize(window.innerWidth, window.innerHeight);  
            renderer.setPixelRatio(window.devicePixelRatio);  
            document.body.appendChild(renderer.domElement);  
  
            // 创建一个 Pivot 组，用于统一旋转  
            pivotGroup = new THREE.Group();  
            scene.add(pivotGroup);  
  
            // 粒子几何体 (创建一个复杂的莫比乌斯环/星云结构)  
            const geometry = new THREE.BufferGeometry();  
            const positions = new Float32Array(particleCount * 3);  
            const colors = new Float32Array(particleCount * 3);  
            const sizes = new Float32Array(particleCount);  
  
            const tempColor = new THREE.Color();  
  
            for (let i = 0; i < particleCount; i++) {  
                // 数学形状：扭曲的环  
                const t = Math.random() * Math.PI * 2;  
                const u = Math.random() * Math.PI * 2;  
                const r = 5 + Math.random() * 2; // 半径粗细  
                  
                // 环面结参数方程  
                const x = (r + 2 * Math.cos(3 * u)) * Math.cos(2 * t);  
                const y = (r + 2 * Math.cos(3 * u)) * Math.sin(2 * t);  
                const z = 2 * Math.sin(3 * u);  
  
                positions[i * 3] = x;  
                positions[i * 3 + 1] = y;  
                positions[i * 3 + 2] = z;  
  
                // 初始颜色  
                tempColor.setHSL(0.5 + Math.random() * 0.1, 0.8, 0.5);  
                colors[i * 3] = tempColor.r;  
                colors[i * 3 + 1] = tempColor.g;  
                colors[i * 3 + 2] = tempColor.b;  
  
                sizes[i] = Math.random();  
            }  
  
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));  
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));  
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));  
  
            // Shader Material 实现更炫酷的效果  
            const material = new THREE.PointsMaterial({  
                size: 0.15,  
                vertexColors: true,  
                blending: THREE.AdditiveBlending,  
                depthWrite: false,  
                transparent: true,  
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png')  
            });  
  
            particleSystem = new THREE.Points(geometry, material);  
            pivotGroup.add(particleSystem);  
  
            window.addEventListener('resize', () => {  
                camera.aspect = window.innerWidth / window.innerHeight;  
                camera.updateProjectionMatrix();  
                renderer.setSize(window.innerWidth, window.innerHeight);  
            });  
        }  
  
        // --- MediaPipe 手势识别逻辑 ---  
        function initMediaPipe() {  
            if (!window.Hands || !window.Camera) {  
                alert("MediaPipe 库加载失败，请检查网络");  
                return;  
            }  
  
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});  
              
            hands.setOptions({  
                maxNumHands: 1, // 单手控制更精准  
                modelComplexity: 1,  
                minDetectionConfidence: 0.7,  
                minTrackingConfidence: 0.7  
            });  
  
            hands.onResults(onHandResults);  
  
            const videoElement = document.getElementById('input-video');  
            const cameraFeed = new window.Camera(videoElement, {  
                onFrame: async () => { await hands.send({image: videoElement}); },  
                width: 320, height: 240  
            });  
            cameraFeed.start().then(() => document.getElementById('loading').style.display = 'none');  
        }  
  
        function onHandResults(results) {  
            const lm = results.multiHandLandmarks;  
            inputState.handDetected = (lm && lm.length > 0);  
  
            if (inputState.handDetected) {  
                const landmarks = lm[0];  
                detectGestureAndAction(landmarks);  
            } else {  
                inputState.gesture = 'NONE';  
                updateUI('NONE');  
                // 无手时缓慢自动旋转  
                inputState.targetRotationY += 0.002;  
            }  
        }  
  
        // --- 核心：手势分类与动作映射 ---  
        function detectGestureAndAction(lm) {  
            // 1. 计算手指伸展状态 (0:拇指, 1:食指, 2:中指, 3:无名指, 4:小指)  
            // 简单的判断：指尖到手腕的距离 > 指关节到手腕的距离  
            const wrist = lm[0];  
            const fingersExtended = [false, false, false, false, false];  
              
            // 拇指特殊处理 (向量判断)  
            // 这里简化处理，用 x 坐标差异判断拇指张开  
            const thumbTip = lm[4];   
            const thumbIp = lm[3];  
            fingersExtended[0] = Math.abs(thumbTip.x - wrist.x) > Math.abs(thumbIp.x - wrist.x); // 简单近似  
  
            // 其他四指 (距离法)  
            const tipIds = [8, 12, 16, 20];  
            const pipIds = [6, 10, 14, 18];  
              
            for(let i=0; i<4; i++) {  
                const tip = lm[tipIds[i]];  
                const pip = lm[pipIds[i]];  
                // 计算欧几里得距离平方  
                const dTip = (tip.x-wrist.x)**2 + (tip.y-wrist.y)**2;  
                const dPip = (pip.x-wrist.x)**2 + (pip.y-wrist.y)**2;  
                fingersExtended[i+1] = dTip > dPip * 1.1; // 1.1 阈值  
            }  
  
            // 2. 状态分类器  
            let gesture = 'UNKNOWN';  
            const count = fingersExtended.filter(Boolean).length;  
  
            if (count === 5) gesture = 'OPEN'; // 全张  
            else if (count === 0 || count === 1 && !fingersExtended[1]) gesture = 'FIST'; // 握拳  
            else if (fingersExtended[1] && !fingersExtended[2] && !fingersExtended[3] && !fingersExtended[4]) gesture = 'POINT'; // 仅食指  
            else if (fingersExtended[1] && fingersExtended[2] && !fingersExtended[3] && !fingersExtended[4]) gesture = 'VICTORY'; // 剪刀手  
  
            inputState.gesture = gesture;  
            updateUI(gesture);  
  
            // 3. 执行逻辑 (状态机)  
            const indexTip = lm[8];  
            const middleTip = lm[12];  
  
            switch (gesture) {  
                case 'OPEN':  
                case 'FIST':  
                    // --- 缩放与爆发模式 ---  
                    // 张开 = 大尺寸 + 爆发色； 握拳 = 小尺寸 + 基础色  
                    const targetBurst = (gesture === 'OPEN') ? 1.0 : 0.0;  
                    // 平滑过渡  
                    inputState.burstFactor += (targetBurst - inputState.burstFactor) * 0.1;  
                    inputState.targetScale = 0.5 + inputState.burstFactor * 1.5;   
                    break;  
  
                case 'POINT':  
                    // --- XY 旋转模式 ---  
                    // 基于上一帧的位置计算 delta  
                    // 注意：Mediapipe x坐标是 0-1，且可能是镜像的，需要处理  
                    const currentX = indexTip.x;  
                    const currentY = indexTip.y;  
  
                    // 如果上一帧不是 Point 模式，重置last，防止跳变  
                    if (inputState.prevGesture !== 'POINT') {  
                        inputState.lastX = currentX;  
                        inputState.lastY = currentY;  
                    }  
  
                    const deltaX = (currentX - inputState.lastX) * 5; // 灵敏度  
                    const deltaY = (currentY - inputState.lastY) * 5;  
  
                    // 屏幕X移动控制 Y轴旋转，屏幕Y移动控制 X轴旋转  
                    inputState.targetRotationY += deltaX;   
                    inputState.targetRotationX += deltaY;   
  
                    inputState.lastX = currentX;  
                    inputState.lastY = currentY;  
                    break;  
  
                case 'VICTORY':  
                    // --- Z 轴翻转模式 (1:1 跟手) ---  
                    // 计算食指(8)和中指(12)连线的角度  
                    // Math.atan2(dy, dx)  
                    // 注意 Y 轴方向在屏幕坐标中是向下的，可能需要取反  
                    const dx = indexTip.x - middleTip.x;  
                    const dy = indexTip.y - middleTip.y; // 屏幕坐标 y 向下  
                      
                    // 计算绝对角度  
                    const angle = Math.atan2(dy, dx);  
                      
                    // 这里有一个偏移，因为剪刀手自然垂直时，dx接近0。  
                    // 我们假设手指水平向右时为0度。  
                    // 直接映射最直观  
                    inputState.targetRotationZ = -angle;   
                    break;  
            }  
  
            inputState.prevGesture = gesture;  
        }  
  
        function updateUI(gesture) {  
            document.getElementById('gesture-name').innerText = gesture;  
              
            // 切换高亮灯  
            const modes = {  
                'OPEN': 'mode-scale',  
                'FIST': 'mode-scale',  
                'POINT': 'mode-rotate-xy',  
                'VICTORY': 'mode-rotate-z'  
            };  
              
            document.querySelectorAll('.mode-box').forEach(el => el.classList.remove('active'));  
            const activeId = modes[gesture];  
            if (activeId) document.getElementById(activeId).classList.add('active');  
        }  
  
        // --- 动画循环 ---  
        function animate() {  
            requestAnimationFrame(animate);  
  
            // 1. 物理平滑插值 (Lerp)  
            // 旋转插值  
            pivotGroup.rotation.x += (inputState.targetRotationX - pivotGroup.rotation.x) * 0.1;  
            pivotGroup.rotation.y += (inputState.targetRotationY - pivotGroup.rotation.y) * 0.1;  
            pivotGroup.rotation.z += (inputState.targetRotationZ - pivotGroup.rotation.z) * 0.1;  
  
            // 缩放插值  
            const currentScale = particleSystem.scale.x;  
            const newScale = currentScale + (inputState.targetScale - currentScale) * 0.1;  
            particleSystem.scale.set(newScale, newScale, newScale);  
  
            // 2. 粒子动态效果  
            const positions = particleSystem.geometry.attributes.position.array;  
            const colors = particleSystem.geometry.attributes.color.array;  
            const time = Date.now() * 0.001;  
              
            // 颜色混合: Base -> Burst  
            const currentColor = new THREE.Color().copy(colorBase).lerp(colorBurst, inputState.burstFactor);  
  
            for (let i = 0; i < particleCount; i++) {  
                // 颜色更新  
                colors[i*3] = currentColor.r;  
                colors[i*3+1] = currentColor.g;  
                colors[i*3+2] = currentColor.b;  
  
                // 简单的湍流运动  
                if (inputState.burstFactor > 0.1) {  
                    // 爆发模式下，粒子剧烈抖动  
                    const shake = inputState.burstFactor * 0.02;  
                    positions[i*3] += (Math.random()-0.5) * shake;  
                    positions[i*3+1] += (Math.random()-0.5) * shake;  
                    positions[i*3+2] += (Math.random()-0.5) * shake;  
                }  
            }  
            particleSystem.geometry.attributes.color.needsUpdate = true;  
            particleSystem.geometry.attributes.position.needsUpdate = true;  
  
            renderer.render(scene, camera);  
              
            // FPS 计算 (简易)  
            document.getElementById('fps-counter').innerText = Math.round(1000 / 16); // 假数据，实际应计算delta  
        }  
  
    </script>  
</body>  
</html>  
