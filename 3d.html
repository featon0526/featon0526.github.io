<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>3D ç²’å­æ‰‹åŠ¿é«˜é˜¶äº¤äº’ç³»ç»Ÿ</title>  
    <style>  
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }  
          
        #hud {  
            position: absolute;  
            top: 20px;  
            left: 20px;  
            color: #00ffcc;  
            pointer-events: none;  
            z-index: 10;  
            text-shadow: 0 0 5px #00ffcc;  
        }  
        .panel-item {   
            margin-bottom: 10px;   
            background: rgba(0, 20, 20, 0.6);   
            padding: 10px;   
            border-left: 3px solid #00ffcc;   
        }  
        h2 { margin: 0 0 5px 0; font-size: 18px; text-transform: uppercase; }  
        p { margin: 0; font-size: 14px; opacity: 0.8; }  
        .highlight { color: #fff; font-weight: bold; }  
  
        #mode-indicator {  
            position: absolute;  
            top: 20px;  
            right: 20px;  
            display: flex;  
            gap: 10px;  
        }  
        .mode-box {  
            padding: 8px 15px;  
            border: 1px solid #333;  
            color: #555;  
            background: rgba(0,0,0,0.8);  
            border-radius: 4px;  
            font-size: 12px;  
            transition: 0.3s;  
        }  
        .mode-box.active {  
            border-color: #00ffcc;  
            color: #00ffcc;  
            background: rgba(0, 255, 204, 0.1);  
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);  
        }  
  
        #video-container {  
            position: absolute;  
            bottom: 20px;  
            left: 20px;  
            width: 200px;  
            height: 150px;  
            border: 2px solid #333;  
            opacity: 0.7;  
            z-index: 5;  
            transform: scaleX(-1);  
            border-radius: 8px;  
        }  
        video {   
            width: 100%;   
            height: 100%;   
            object-fit: cover;  
            border-radius: 6px;  
        }  
          
        #loading {  
            position: absolute;  
            top: 50%; left: 50%;   
            transform: translate(-50%, -50%);  
            color: white;   
            font-size: 20px;  
            text-align: center;  
            background: rgba(0,0,0,0.8);  
            padding: 20px;  
            border-radius: 10px;  
        }  
          
        #error {  
            position: absolute;  
            top: 50%; left: 50%;  
            transform: translate(-50%, -50%);  
            color: #ff6b6b;  
            font-size: 18px;  
            text-align: center;  
            background: rgba(0,0,0,0.9);  
            padding: 20px;  
            border-radius: 10px;  
            display: none;  
        }  
    </style>  
</head>  
<body>  
  
    <div id="loading">æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´å’ŒAIæ¨¡å‹...</div>  
    <div id="error"></div>  
  
    <div id="hud">  
        <div class="panel-item">  
            <h2>ç³»ç»ŸçŠ¶æ€</h2>  
            <p>æ‰‹åŠ¿: <span id="gesture-name" class="highlight">åˆå§‹åŒ–ä¸­</span></p>  
            <p>æ£€æµ‹åˆ°æ‰‹: <span id="hand-status" class="highlight">å¦</span></p>  
            <p>FPS: <span id="fps-counter">0</span></p>  
        </div>  
        <div class="panel-item">  
            <h2>æ“ä½œæŒ‡å—</h2>  
            <p>âœ‹ [å¼ å¼€æ‰‹æŒ] -> èƒ½é‡çˆ†å‘/æ”¾å¤§</p>  
            <p>â˜ï¸ [åªä¼¸é£ŸæŒ‡] -> XYè½´æ—‹è½¬ (ç§»åŠ¨æ‰‹æ§åˆ¶è§†è§’)</p>  
            <p>âœŒï¸ [å‰ªåˆ€æ‰‹] -> Zè½´ç¿»è½¬ (æ—‹è½¬æ‰‹è…•æ§åˆ¶æ»šè½¬)</p>  
            <p>ğŸ‘Š [æ¡æ‹³] -> æ”¶ç¼©/å¹³é™æ¨¡å¼</p>  
        </div>  
    </div>  
  
    <div id="mode-indicator">  
        <div id="mode-scale" class="mode-box">ç¼©æ”¾/çˆ†å‘æ¨¡å¼</div>  
        <div id="mode-rotate-xy" class="mode-box">XY è§†è§’æ—‹è½¬</div>  
        <div id="mode-rotate-z" class="mode-box">Z å¹³é¢ç¿»è½¬</div>  
    </div>  
  
    <div id="video-container">  
        <video id="input-video" playsinline style="display: none;"></video>  
    </div>  
  
    <script type="importmap">  
        {  
            "imports": {  
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"  
            }  
        }  
    </script>  
  
    <script type="module">  
        import * as THREE from 'three';  
  
        // --- å…¨å±€å˜é‡ ---  
        let scene, camera, renderer, particleSystem, pivotGroup;  
        let handLandmarker, videoElement, animationId;  
        const particleCount = 15000;  
          
        // äº¤äº’çŠ¶æ€  
        const inputState = {  
            gesture: 'NONE',  
            handDetected: false,  
            lastX: 0, lastY: 0,  
            targetRotationX: 0, targetRotationY: 0, targetRotationZ: 0,  
            targetScale: 1,  
            burstFactor: 0,  
            prevGesture: null,  
            lastTime: 0,  
            frameCount: 0  
        };  
  
        const colorBase = new THREE.Color('#00aaff');  
        const colorBurst = new THREE.Color('#ff0055');  
  
        // --- é”™è¯¯å¤„ç† ---  
        function showError(message) {  
            const loading = document.getElementById('loading');  
            const error = document.getError('error');  
            loading.style.display = 'none';  
            error.innerHTML = `  
                <div>${message}</div>  
                <div style="margin-top: 10px; font-size: 14px; color: #ff9999;">  
                    è¯·æ£€æŸ¥ï¼š<br>  
                    1. æµè§ˆå™¨æ˜¯å¦æ”¯æŒWebGL<br>  
                    2. æ‘„åƒå¤´æƒé™æ˜¯å¦å·²æˆäºˆ<br>  
                    3. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸<br>  
                    4. å°è¯•åˆ·æ–°é¡µé¢æˆ–æ›´æ¢æµè§ˆå™¨  
                </div>  
            `;  
            error.style.display = 'block';  
        }  
  
        // --- Three.js åˆå§‹åŒ– ---  
        function initThree() {  
            try {  
                scene = new THREE.Scene();  
                scene.fog = new THREE.FogExp2(0x050505, 0.02);  
  
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);  
                camera.position.z = 15;  
  
                renderer = new THREE.WebGLRenderer({ antialias: true });  
                renderer.setSize(window.innerWidth, window.innerHeight);  
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  
                document.body.appendChild(renderer.domElement);  
  
                // Pivotç»„  
                pivotGroup = new THREE.Group();  
                scene.add(pivotGroup);  
  
                // ç²’å­ç³»ç»Ÿ  
                const geometry = new THREE.BufferGeometry();  
                const positions = new Float32Array(particleCount * 3);  
                const colors = new Float32Array(particleCount * 3);  
                const sizes = new Float32Array(particleCount);  
  
                for (let i = 0; i < particleCount; i++) {  
                    const t = Math.random() * Math.PI * 2;  
                    const u = Math.random() * Math.PI * 2;  
                    const r = 4 + Math.random() * 3;  
  
                    const x = (r + 1.5 * Math.cos(2 * u)) * Math.cos(t);  
                    const y = (r + 1.5 * Math.cos(2 * u)) * Math.sin(t);  
                    const z = 1.5 * Math.sin(2 * u);  
  
                    positions[i * 3] = x;  
                    positions[i * 3 + 1] = y;  
                    positions[i * 3 + 2] = z;  
  
                    const tempColor = new THREE.Color().setHSL(0.5 + Math.random() * 0.1, 0.8, 0.5);  
                    colors[i * 3] = tempColor.r;  
                    colors[i * 3 + 1] = tempColor.g;  
                    colors[i * 3 + 2] = tempColor.b;  
  
                    sizes[i] = Math.random() * 0.5 + 0.1;  
                }  
  
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));  
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));  
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));  
  
                const material = new THREE.ShaderMaterial({  
                    uniforms: {  
                        time: { value: 0 }  
                    },  
                    vertexShader: `  
                        attribute float size;  
                        varying vec3 vColor;  
                        uniform float time;  
                          
                        void main() {  
                            vColor = color;  
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);  
                            gl_PointSize = size * (300.0 / -mvPosition.z);  
                            gl_Position = projectionMatrix * mvPosition;  
                        }  
                    `,  
                    fragmentShader: `  
                        varying vec3 vColor;  
                          
                        void main() {  
                            float r = distance(gl_PointCoord, vec2(0.5));  
                            if (r > 0.5) discard;  
                            gl_FragColor = vec4(vColor, 1.0 - r * 2.0);  
                        }  
                    `,  
                    vertexColors: true,  
                    transparent: true,  
                    blending: THREE.AdditiveBlending,  
                    depthWrite: false  
                });  
  
                particleSystem = new THREE.Points(geometry, material);  
                pivotGroup.add(particleSystem);  
  
                // çª—å£è°ƒæ•´  
                window.addEventListener('resize', () => {  
                    camera.aspect = window.innerWidth / window.innerHeight;  
                    camera.updateProjectionMatrix();  
                    renderer.setSize(window.innerWidth, window.innerHeight);  
                });  
  
            } catch (error) {  
                showError(`Three.js åˆå§‹åŒ–å¤±è´¥: ${error.message}`);  
                console.error('Three.js Error:', error);  
            }  
        }  
  
        // --- æ”¹è¿›çš„æ‰‹åŠ¿è¯†åˆ« ---  
        function detectGesture(landmarks) {  
            if (!landmarks || landmarks.length < 21) return 'NONE';  
  
            // å…³é”®ç‚¹ç´¢å¼•  
            const wrist = landmarks[0];  
            const thumbTip = landmarks[4];  
            const indexTip = landmarks[8];  
            const middleTip = landmarks[12];  
            const ringTip = landmarks[16];  
            const pinkyTip = landmarks[20];  
              
            // æŒ‡å…³èŠ‚ç‚¹  
            const thumbIp = landmarks[3];  
            const indexPip = landmarks[6];  
            const middlePip = landmarks[10];  
            const ringPip = landmarks[14];  
            const pinkyPip = landmarks[18];  
  
            // æ”¹è¿›çš„ä¼¸å±•æ£€æµ‹  
            const fingersExtended = [];  
  
            // æ‹‡æŒ‡æ£€æµ‹ (ä½¿ç”¨å‘é‡å¤¹è§’)  
            const thumbVector = {  
                x: thumbTip.x - thumbIp.x,  
                y: thumbTip.y - thumbIp.y,  
                z: thumbTip.z - thumbIp.z  
            };  
            const palmVector = {  
                x: wrist.x - landmarks[5].x, // æŒå¿ƒ  
                y: wrist.y - landmarks[5].y,  
                z: wrist.z - landmarks[5].z  
            };  
              
            // è®¡ç®—å¤¹è§’ (cosÎ¸ = (AÂ·B)/(|A||B|))  
            const dotProduct = thumbVector.x * palmVector.x +   
                              thumbVector.y * palmVector.y +   
                              thumbVector.z * palmVector.z;  
            const thumbMag = Math.sqrt(thumbVector.x**2 + thumbVector.y**2 + thumbVector.z**2);  
            const palmMag = Math.sqrt(palmVector.x**2 + palmVector.y**2 + palmVector.z**2);  
            const cosAngle = Math.max(-1, Math.min(1, dotProduct / (thumbMag * palmMag)));  
            fingersExtended[0] = cosAngle < 0.3; // æ‹‡æŒ‡ä¸æŒå¿ƒå¤¹è§’ > çº¦73åº¦  
  
            // å…¶ä»–æ‰‹æŒ‡ - æ”¹è¿›çš„è·ç¦»+è§’åº¦æ£€æµ‹  
            const fingerTips = [indexTip, middleTip, ringTip, pinkyTip];  
            const fingerPips = [indexPip, middlePip, ringPip, pinkyPip];  
  
            for (let i = 0; i < 4; i++) {  
                const tip = fingerTips[i];  
                const pip = fingerPips[i];  
                  
                // è·ç¦»æ£€æµ‹  
                const distTipWrist = Math.sqrt(  
                    (tip.x - wrist.x)**2 + (tip.y - wrist.y)**2 + (tip.z - wrist.z)**2  
                );  
                const distPipWrist = Math.sqrt(  
                    (pip.x - wrist.x)**2 + (pip.y - wrist.y)**2 + (pip.z - wrist.z)**2  
                );  
                  
                // è§’åº¦æ£€æµ‹ (æŒ‡å°–-æŒ‡å…³èŠ‚-æ‰‹è…•)  
                const fingerVector = {x: tip.x - pip.x, y: tip.y - pip.y, z: tip.z - pip.z};  
                const wristVector = {x: pip.x - wrist.x, y: pip.y - wrist.y, z: pip.z - wrist.z};  
                  
                const fingerDot = fingerVector.x * wristVector.x +   
                                 fingerVector.y * wristVector.y +   
                                 fingerVector.z * wristVector.z;  
                const fingerMag = Math.sqrt(fingerVector.x**2 + fingerVector.y**2 + fingerVector.z**2);  
                const wristMag = Math.sqrt(wristVector.x**2 + wristVector.y**2 + wristVector.z**2);  
                const fingerCos = Math.max(-1, Math.min(1, fingerDot / (fingerMag * wristMag)));  
                  
                // ä¼¸å±•æ¡ä»¶ï¼šè·ç¦»è¶³å¤Ÿ + è§’åº¦æ¥è¿‘180åº¦  
                const isExtended = distTipWrist > distPipWrist * 1.3 && fingerCos > 0.7;  
                fingersExtended[i + 1] = isExtended;  
            }  
  
            // æ‰‹åŠ¿åˆ†ç±» (æ›´ä¸¥æ ¼çš„æ¡ä»¶)  
            const extendedCount = fingersExtended.filter(Boolean).length;  
              
            if (extendedCount >= 4) {  
                return 'OPEN'; // å¼ å¼€æ‰‹æŒ  
            } else if (extendedCount <= 1 && !fingersExtended[1]) {  
                return 'FIST'; // æ¡æ‹³  
            } else if (fingersExtended[1] && !fingersExtended[2] && !fingersExtended[3] && !fingersExtended[4]) {  
                return 'POINT'; // æŒ‡å‘  
            } else if (fingersExtended[1] && fingersExtended[2] && !fingersExtended[3] && !fingersExtended[4]) {  
                return 'VICTORY'; // å‰ªåˆ€æ‰‹  
            }  
              
            return 'UNKNOWN';  
        }  
  
        // --- MediaPipe Hands åˆå§‹åŒ– (æ–°ç‰ˆæœ¬) ---  
        async function initMediaPipe() {  
            try {  
                document.getElementById('loading').innerText = 'åŠ è½½AIæ¨¡å‹...';  
                  
                // åŠ è½½æ¨¡å‹  
                const vision = await FilesetResolver.forVisionTasks(  
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"  
                );  
                  
                document.getElementById('loading').innerText = 'åˆ›å»ºæ‰‹éƒ¨æ£€æµ‹å™¨...';  
                handLandmarker = await HandLandmarker.createFromOptions(vision, {  
                    baseOptions: {  
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`  
                    },  
                    runningMode: 'VIDEO',  
                    numHands: 1,  
                    minHandDetectionConfidence: 0.7,  
                    minTrackingConfidence: 0.5,  
                    minHandPresenceConfidence: 0.7  
                });  
  
                document.getElementById('loading').innerText = 'åˆå§‹åŒ–æ‘„åƒå¤´...';  
                  
                // æ‘„åƒå¤´è®¾ç½®  
                videoElement = document.getElementById('input-video');  
                videoElement.style.display = 'block';  
                  
                const stream = await navigator.mediaDevices.getUserMedia({  
                    video: {  
                        width: 640,  
                        height: 480,  
                        facingMode: 'user'  
                    }  
                });  
                  
                videoElement.srcObject = stream;  
                await videoElement.play();  
                  
                // å¼€å§‹å¤„ç†  
                document.getElementById('loading').innerText = 'å¼€å§‹æ‰‹åŠ¿è¯†åˆ«...';  
                startHandTracking();  
                  
                setTimeout(() => {  
                    document.getElementById('loading').style.display = 'none';  
                }, 1000);  
                  
            } catch (error) {  
                console.error('MediaPipe Error:', error);  
                showError(`æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥: ${error.message}`);  
            }  
        }  
  
        // --- æ‰‹éƒ¨è·Ÿè¸ª ---  
        function startHandTracking() {  
            async function predictWebcam() {  
                if (!handLandmarker || !videoElement) return;  
                  
                const startTimeMs = performance.now();  
                if (!videoElement.videoWidth) {  
                    animationId = requestAnimationFrame(predictWebcam);  
                    return;  
                }  
  
                const results = await handLandmarker.detectForVideo(videoElement, startTimeMs);  
                  
                if (results.landmarks && results.landmarks.length > 0) {  
                    inputState.handDetected = true;  
                    const gesture = detectGesture(results.landmarks[0]);  
                    inputState.gesture = gesture;  
                      
                    // æ‰§è¡Œæ‰‹åŠ¿åŠ¨ä½œ  
                    processGesture(results.landmarks[0], gesture);  
                } else {  
                    inputState.handDetected = false;  
                    inputState.gesture = 'NONE';  
                    // æ— æ‰‹æ—¶ç¼“æ…¢æ—‹è½¬  
                    inputState.targetRotationY += 0.001;  
                }  
                  
                updateUI();  
                animationId = requestAnimationFrame(predictWebcam);  
            }  
              
            predictWebcam();  
        }  
  
        // --- å¤„ç†æ‰‹åŠ¿åŠ¨ä½œ ---  
        function processGesture(landmarks, gesture) {  
            const indexTip = landmarks[8];  
            const middleTip = landmarks[12];  
  
            switch (gesture) {  
                case 'OPEN':  
                case 'FIST':  
                    const targetBurst = (gesture === 'OPEN') ? 1.0 : 0.0;  
                    inputState.burstFactor += (targetBurst - inputState.burstFactor) * 0.15;  
                    inputState.targetScale = 0.6 + inputState.burstFactor * 1.4;  
                    break;  
  
                case 'POINT':  
                    if (inputState.prevGesture !== 'POINT') {  
                        inputState.lastX = indexTip.x * window.innerWidth;  
                        inputState.lastY = indexTip.y * window.innerHeight;  
                    } else {  
                        const currentX = indexTip.x * window.innerWidth;  
                        const currentY = indexTip.y * window.innerHeight;  
                          
                        const deltaX = (currentX - inputState.lastX) * 0.005;  
                        const deltaY = (currentY - inputState.lastY) * 0.005;  
                          
                        inputState.targetRotationY += deltaX;  
                        inputState.targetRotationX -= deltaY; // Yè½´åå‘  
                          
                        inputState.lastX = currentX;  
                        inputState.lastY = currentY;  
                    }  
                    break;  
  
                case 'VICTORY':  
                    const dx = indexTip.x - middleTip.x;  
                    const dy = indexTip.y - middleTip.y;  
                    const angle = Math.atan2(dy, dx);  
                    inputState.targetRotationZ = angle * 1.5;  
                    break;  
            }  
              
            inputState.prevGesture = gesture;  
        }  
  
        // --- UI æ›´æ–° ---  
        function updateUI() {  
            document.getElementById('gesture-name').innerText = inputState.gesture;  
            document.getElementById('hand-status').innerText = inputState.handDetected ? 'æ˜¯' : 'å¦';  
  
            // æ¨¡å¼æŒ‡ç¤ºç¯  

            const modes = {  
                'OPEN': 'mode-scale',  
                'FIST': 'mode-scale',  
                'POINT': 'mode-rotate-xy',  
                'VICTORY': 'mode-rotate-z'  
            };  
              
            document.querySelectorAll('.mode-box').forEach(el => el.classList.remove('active'));  
            const activeMode = modes[inputState.gesture];  
            if (activeMode) {  
                document.getElementById(activeMode).classList.add('active');  
            }  
  
            // FPS è®¡ç®—  
            const currentTime = performance.now();  
            inputState.frameCount++;  
            if (currentTime - inputState.lastTime >= 1000) {  
                const fps = Math.round((inputState.frameCount * 1000) / (currentTime - inputState.lastTime));  
                document.getElementById('fps-counter').innerText = fps;  
                inputState.frameCount = 0;  
                inputState.lastTime = currentTime;  
            }  
        }  
  
        // --- ä¸»åŠ¨ç”»å¾ªç¯ ---  
        function animate() {  
            if (!renderer || !scene || !camera) return;  
              
            // å¹³æ»‘æ’å€¼  
            pivotGroup.rotation.x += (inputState.targetRotationX - pivotGroup.rotation.x) * 0.08;  
            pivotGroup.rotation.y += (inputState.targetRotationY - pivotGroup.rotation.y) * 0.08;  
            pivotGroup.rotation.z += (inputState.targetRotationZ - pivotGroup.rotation.z) * 0.08;  
  
            const currentScale = particleSystem.scale.x;  
            const newScale = currentScale + (inputState.targetScale - currentScale) * 0.1;  
            particleSystem.scale.set(newScale, newScale, newScale);  
  
            // ç²’å­åŠ¨æ€æ•ˆæœ  
            const positions = particleSystem.geometry.attributes.position.array;  
            const time = Date.now() * 0.001;  
              
            // é¢œè‰²è¿‡æ¸¡  
            const currentColor = new THREE.Color().copy(colorBase).lerp(colorBurst, inputState.burstFactor);  
              
            for (let i = 0; i < particleCount; i++) {  
                // é¢œè‰²æ›´æ–°  
                positions[i*3] += Math.sin(time + i * 0.01) * 0.005 * inputState.burstFactor;  
                positions[i*3+1] += Math.cos(time * 1.3 + i * 0.01) * 0.003 * inputState.burstFactor;  
                  
                // çˆ†å‘æ•ˆæœ  
                if (inputState.burstFactor > 0.3) {  
                    const intensity = inputState.burstFactor * 0.03;  
                    positions[i*3] += (Math.random() - 0.5) * intensity;  
                    positions[i*3+1] += (Math.random() - 0.5) * intensity;  
                    positions[i*3+2] += (Math.random() - 0.5) * intensity;  
                }  
            }  
              
            particleSystem.geometry.attributes.position.needsUpdate = true;  
              
            // é™åˆ¶æ—‹è½¬è§’åº¦  
            pivotGroup.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pivotGroup.rotation.x));  
            pivotGroup.rotation.y = pivotGroup.rotation.y % (Math.PI * 2);  
            pivotGroup.rotation.z = Math.max(-Math.PI/2, Math.min(Math.PI/2, pivotGroup.rotation.z));  
              
            renderer.render(scene, camera);  
            requestAnimationFrame(animate);  
        }  
  
        // --- åˆå§‹åŒ–å¯åŠ¨ ---  
        async function init() {  
            try {  
                initThree();  
                  
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ  
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {  
                    showError('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®');  
                    return;  
                }  
                  
                if (!window.WebGLRenderingContext) {  
                    showError('æµè§ˆå™¨ä¸æ”¯æŒWebGL');  
                    return;  
                }  
                  
                await initMediaPipe();  
                animate();  
                  
            } catch (error) {  
                showError(`ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: ${error.message}`);  
                console.error('Init Error:', error);  
            }  
        }  
  
        // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨  
        window.addEventListener('load', init);  
          
        // é¡µé¢å¸è½½æ—¶æ¸…ç†  
        window.addEventListener('beforeunload', () => {  
            if (videoElement && videoElement.srcObject) {  
                videoElement.srcObject.getTracks().forEach(track => track.stop());  
            }  
            if (animationId) {  
                cancelAnimationFrame(animationId);  
            }  
        });  
  
    </script>  
</body>  
</html>  
